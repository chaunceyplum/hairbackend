# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off
from __future__ import annotations

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template actions.py.jinja --
from typing import TypeVar
import warnings

from . import types, errors, bases

if TYPE_CHECKING:
    from .client import Client
    from .bases import _PrismaModel


_PrismaModelT = TypeVar('_PrismaModelT', bound='_PrismaModel')


class AppointmentActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Appointment]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = Appointment.prisma().query_raw(
            'SELECT * FROM Appointment WHERE appointmentId = $1',
            1103527590,
        )
        ```
        """
        return self._client.query_raw(query, *args, model=self._model)

    def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Appointment
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = Appointment.prisma().query_first(
            'SELECT * FROM Appointment WHERE fcustomerId = $1',
            377401575,
        )
        ```
        """
        return self._client.query_first(query, *args, model=self._model)

    def create(
        self,
        data: types.AppointmentCreateInput,
        include: Optional[types.AppointmentInclude] = None
    ) -> _PrismaModelT:
        """Create a new Appointment record.

        Parameters
        ----------
        data
            Appointment record data
        include
            Specifies which relations should be loaded on the returned Appointment model

        Returns
        -------
        prisma.models.Appointment
            The created Appointment record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Appointment record from just the required fields
        appointment = Appointment.prisma().create(
            data={
                # data to create a Appointment record
                'fcustomerId': 662824084,
                'fbarberId': 1147902781,
                'Date': datetime.datetime.utcnow(),
                'appointmentDate': datetime.datetime.utcnow(),
                'phoneNumber': 'cadfabfehe',
            },
        )
        ```
        """
        resp = self._client._execute(
            operation='mutation',
            method='createOne',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    def create_many(
        self,
        data: List[types.AppointmentCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Appointment records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Appointment record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = Appointment.prisma().create_many(
            data=[
                {
                    # data to create a Appointment record
                    'fcustomerId': 368800899,
                    'fbarberId': 1508029952,
                    'Date': datetime.datetime.utcnow(),
                    'appointmentDate': datetime.datetime.utcnow(),
                    'phoneNumber': 'eigcfgbif',
                },
                {
                    # data to create a Appointment record
                    'fcustomerId': 1062517886,
                    'fbarberId': 267834847,
                    'Date': datetime.datetime.utcnow(),
                    'appointmentDate': datetime.datetime.utcnow(),
                    'phoneNumber': 'biabhbdai',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = self._client._execute(
            operation='mutation',
            method='createMany',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    def delete(
        self,
        where: types.AppointmentWhereUniqueInput,
        include: Optional[types.AppointmentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Appointment record.

        Parameters
        ----------
        where
            Appointment filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Appointment model

        Returns
        -------
        prisma.models.Appointment
            The deleted Appointment record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        appointment = Appointment.prisma().delete(
            where={
                'appointmentId': 836760821,
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                operation='mutation',
                method='deleteOne',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    def find_unique(
        self,
        where: types.AppointmentWhereUniqueInput,
        include: Optional[types.AppointmentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Appointment record.

        Parameters
        ----------
        where
            Appointment filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Appointment model

        Returns
        -------
        prisma.models.Appointment
            The found Appointment record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        appointment = Appointment.prisma().find_unique(
            where={
                'appointmentId': 595337866,
            },
        )
        ```
        """
        resp = self._client._execute(
            operation='query',
            method='findUnique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AppointmentWhereInput] = None,
        cursor: Optional[types.AppointmentWhereUniqueInput] = None,
        include: Optional[types.AppointmentInclude] = None,
        order: Optional[Union[types.AppointmentOrderByInput, List[types.AppointmentOrderByInput]]] = None,
        distinct: Optional[List[types.AppointmentScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Appointment records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Appointment records returned
        skip
            Ignore the first N results
        where
            Appointment filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Appointment model
        order
            Order the returned Appointment records by any field
        distinct
            Filter Appointment records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Appointment]
            The list of all Appointment records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Appointment records
        appointments = Appointment.prisma().find_many(take=10)

        # find the first 5 Appointment records ordered by the fbarberId field
        appointments = Appointment.prisma().find_many(
            take=5,
            order={
                'fbarberId': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            operation='query',
            method='findMany',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [self._model.parse_obj(r) for r in resp['data']['result']]

    def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AppointmentWhereInput] = None,
        cursor: Optional[types.AppointmentWhereUniqueInput] = None,
        include: Optional[types.AppointmentInclude] = None,
        order: Optional[Union[types.AppointmentOrderByInput, List[types.AppointmentOrderByInput]]] = None,
        distinct: Optional[List[types.AppointmentScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Appointment record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Appointment filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Appointment model
        order
            Order the returned Appointment records by any field
        distinct
            Filter Appointment records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Appointment
            The first Appointment record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Appointment record ordered by the Date field
        appointment = Appointment.prisma().find_first(
            skip=1,
            order={
                'Date': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            operation='query',
            method='findFirst',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    def update(
        self,
        data: types.AppointmentUpdateInput,
        where: types.AppointmentWhereUniqueInput,
        include: Optional[types.AppointmentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Appointment record.

        Parameters
        ----------
        data
            Appointment record data specifying what to update
        where
            Appointment filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Appointment model

        Returns
        -------
        prisma.models.Appointment
            The updated Appointment record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        appointment = Appointment.prisma().update(
            where={
                'appointmentId': 790425851,
            },
            data={
                # data to update the Appointment record to
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                operation='mutation',
                method='updateOne',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    def upsert(
        self,
        where: types.AppointmentWhereUniqueInput,
        data: types.AppointmentUpsertInput,
        include: Optional[types.AppointmentInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Appointment filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Appointment model

        Returns
        -------
        prisma.models.Appointment
            The created or updated Appointment record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        appointment = Appointment.prisma().upsert(
            where={
                'appointmentId': 2111915288,
            },
            data={
                'create': {
                    'appointmentId': 2111915288,
                    'fcustomerId': 1062517886,
                    'fbarberId': 267834847,
                    'Date': datetime.datetime.utcnow(),
                    'appointmentDate': datetime.datetime.utcnow(),
                    'phoneNumber': 'biabhbdai',
                },
                'update': {
                    'fcustomerId': 1062517886,
                    'fbarberId': 267834847,
                    'Date': datetime.datetime.utcnow(),
                    'appointmentDate': datetime.datetime.utcnow(),
                    'phoneNumber': 'biabhbdai',
                },
            },
        )
        ```
        """
        resp = self._client._execute(
            operation='mutation',
            method='upsertOne',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    def update_many(
        self,
        data: types.AppointmentUpdateManyMutationInput,
        where: types.AppointmentWhereInput,
    ) -> int:
        """Update multiple Appointment records

        Parameters
        ----------
        data
            Appointment data to update the selected Appointment records to
        where
            Filter to select the Appointment records to update

        Returns
        -------
        int
            The total number of Appointment records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Appointment records
        total = Appointment.prisma().update_many(
            data={
                'appointmentDate': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = self._client._execute(
            operation='mutation',
            method='updateMany',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AppointmentWhereInput] = None,
        cursor: Optional[types.AppointmentWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Appointment records present in the database

        Parameters
        ----------
        select
            Select the Appointment fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Appointment filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AppointmentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = Appointment.prisma().count()

        # results: prisma.types.AppointmentCountAggregateOutput
        results = Appointment.prisma().count(
            select={
                '_all': True,
                'phoneNumber': True,
            },
        )
        ```
        """


    @overload
    def count(
        self,
        select: types.AppointmentCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AppointmentWhereInput] = None,
        cursor: Optional[types.AppointmentWhereUniqueInput] = None,
    ) -> types.AppointmentCountAggregateOutput:
        ...

    def count(
        self,
        select: Optional[types.AppointmentCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AppointmentWhereInput] = None,
        cursor: Optional[types.AppointmentWhereUniqueInput] = None,
    ) -> Union[int, types.AppointmentCountAggregateOutput]:
        """Count the number of Appointment records present in the database

        Parameters
        ----------
        select
            Select the Appointment fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Appointment filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AppointmentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = Appointment.prisma().count()

        # results: prisma.types.AppointmentCountAggregateOutput
        results = Appointment.prisma().count(
            select={
                '_all': True,
                'appointmentId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = self._client._execute(
            operation='query',
            method='aggregate',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.AppointmentCountAggregateOutput, resp['data']['result']['_count'])

    def delete_many(
        self,
        where: Optional[types.AppointmentWhereInput] = None
    ) -> int:
        """Delete multiple Appointment records.

        Parameters
        ----------
        where
            Optional Appointment filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Appointment records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Appointment records
        total = Appointment.prisma().delete_many()
        ```
        """
        resp = self._client._execute(
            operation='mutation',
            method='deleteMany',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    def group_by(
        self,
        by: List['types.AppointmentScalarFieldKeys'],
        *,
        where: Optional['types.AppointmentWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.AppointmentAvgAggregateInput'] = None,
        sum: Optional['types.AppointmentSumAggregateInput'] = None,
        min: Optional['types.AppointmentMinAggregateInput'] = None,
        max: Optional['types.AppointmentMaxAggregateInput'] = None,
        having: Optional['types.AppointmentScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.AppointmentCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.AppointmentScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.AppointmentScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.AppointmentGroupByOutput']:
        """Group Appointment records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Appointment fields to group records by
        where
            Appointment filter to select records
        take
            Limit the maximum number of Appointment records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.AppointmentGroupByOutput]
            A list of dictionaries representing the Appointment record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Appointment records by fcustomerId values
        # and count how many records are in each group
        results = Appointment.prisma().group_by(
            ['fcustomerId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = self._client._execute(
            operation='query',
            method='groupBy',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class BarberActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Barber]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = Barber.prisma().query_raw(
            'SELECT * FROM Barber WHERE barberid = $1',
            1149758321,
        )
        ```
        """
        return self._client.query_raw(query, *args, model=self._model)

    def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Barber
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = Barber.prisma().query_first(
            'SELECT * FROM Barber WHERE firstname = $1',
            'bgeecijdgg',
        )
        ```
        """
        return self._client.query_first(query, *args, model=self._model)

    def create(
        self,
        data: types.BarberCreateInput,
        include: Optional[types.BarberInclude] = None
    ) -> _PrismaModelT:
        """Create a new Barber record.

        Parameters
        ----------
        data
            Barber record data
        include
            Specifies which relations should be loaded on the returned Barber model

        Returns
        -------
        prisma.models.Barber
            The created Barber record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Barber record from just the required fields
        barber = Barber.prisma().create(
            data={
                # data to create a Barber record
                'firstname': 'bdiicjafbj',
            },
        )
        ```
        """
        resp = self._client._execute(
            operation='mutation',
            method='createOne',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    def create_many(
        self,
        data: List[types.BarberCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Barber records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Barber record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = Barber.prisma().create_many(
            data=[
                {
                    # data to create a Barber record
                    'firstname': 'bgehebiafc',
                },
                {
                    # data to create a Barber record
                    'firstname': 'bghffegacj',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = self._client._execute(
            operation='mutation',
            method='createMany',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    def delete(
        self,
        where: types.BarberWhereUniqueInput,
        include: Optional[types.BarberInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Barber record.

        Parameters
        ----------
        where
            Barber filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Barber model

        Returns
        -------
        prisma.models.Barber
            The deleted Barber record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        barber = Barber.prisma().delete(
            where={
                'barberid': 1767274722,
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                operation='mutation',
                method='deleteOne',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    def find_unique(
        self,
        where: types.BarberWhereUniqueInput,
        include: Optional[types.BarberInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Barber record.

        Parameters
        ----------
        where
            Barber filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Barber model

        Returns
        -------
        prisma.models.Barber
            The found Barber record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        barber = Barber.prisma().find_unique(
            where={
                'barberid': 326272115,
            },
        )
        ```
        """
        resp = self._client._execute(
            operation='query',
            method='findUnique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BarberWhereInput] = None,
        cursor: Optional[types.BarberWhereUniqueInput] = None,
        include: Optional[types.BarberInclude] = None,
        order: Optional[Union[types.BarberOrderByInput, List[types.BarberOrderByInput]]] = None,
        distinct: Optional[List[types.BarberScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Barber records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Barber records returned
        skip
            Ignore the first N results
        where
            Barber filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Barber model
        order
            Order the returned Barber records by any field
        distinct
            Filter Barber records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Barber]
            The list of all Barber records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Barber records
        barbers = Barber.prisma().find_many(take=10)

        # find the first 5 Barber records ordered by the barberid field
        barbers = Barber.prisma().find_many(
            take=5,
            order={
                'barberid': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            operation='query',
            method='findMany',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [self._model.parse_obj(r) for r in resp['data']['result']]

    def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.BarberWhereInput] = None,
        cursor: Optional[types.BarberWhereUniqueInput] = None,
        include: Optional[types.BarberInclude] = None,
        order: Optional[Union[types.BarberOrderByInput, List[types.BarberOrderByInput]]] = None,
        distinct: Optional[List[types.BarberScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Barber record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Barber filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Barber model
        order
            Order the returned Barber records by any field
        distinct
            Filter Barber records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Barber
            The first Barber record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Barber record ordered by the firstname field
        barber = Barber.prisma().find_first(
            skip=1,
            order={
                'firstname': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            operation='query',
            method='findFirst',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    def update(
        self,
        data: types.BarberUpdateInput,
        where: types.BarberWhereUniqueInput,
        include: Optional[types.BarberInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Barber record.

        Parameters
        ----------
        data
            Barber record data specifying what to update
        where
            Barber filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Barber model

        Returns
        -------
        prisma.models.Barber
            The updated Barber record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        barber = Barber.prisma().update(
            where={
                'barberid': 1343201072,
            },
            data={
                # data to update the Barber record to
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                operation='mutation',
                method='updateOne',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    def upsert(
        self,
        where: types.BarberWhereUniqueInput,
        data: types.BarberUpsertInput,
        include: Optional[types.BarberInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Barber filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Barber model

        Returns
        -------
        prisma.models.Barber
            The created or updated Barber record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        barber = Barber.prisma().upsert(
            where={
                'barberid': 675780521,
            },
            data={
                'create': {
                    'barberid': 675780521,
                    'firstname': 'bghffegacj',
                },
                'update': {
                    'firstname': 'bghffegacj',
                },
            },
        )
        ```
        """
        resp = self._client._execute(
            operation='mutation',
            method='upsertOne',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    def update_many(
        self,
        data: types.BarberUpdateManyMutationInput,
        where: types.BarberWhereInput,
    ) -> int:
        """Update multiple Barber records

        Parameters
        ----------
        data
            Barber data to update the selected Barber records to
        where
            Filter to select the Barber records to update

        Returns
        -------
        int
            The total number of Barber records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Barber records
        total = Barber.prisma().update_many(
            data={
                'barberid': 744964398
            },
            where={}
        )
        ```
        """
        resp = self._client._execute(
            operation='mutation',
            method='updateMany',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BarberWhereInput] = None,
        cursor: Optional[types.BarberWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Barber records present in the database

        Parameters
        ----------
        select
            Select the Barber fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Barber filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.BarberCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = Barber.prisma().count()

        # results: prisma.types.BarberCountAggregateOutput
        results = Barber.prisma().count(
            select={
                '_all': True,
                'firstname': True,
            },
        )
        ```
        """


    @overload
    def count(
        self,
        select: types.BarberCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BarberWhereInput] = None,
        cursor: Optional[types.BarberWhereUniqueInput] = None,
    ) -> types.BarberCountAggregateOutput:
        ...

    def count(
        self,
        select: Optional[types.BarberCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BarberWhereInput] = None,
        cursor: Optional[types.BarberWhereUniqueInput] = None,
    ) -> Union[int, types.BarberCountAggregateOutput]:
        """Count the number of Barber records present in the database

        Parameters
        ----------
        select
            Select the Barber fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Barber filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.BarberCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = Barber.prisma().count()

        # results: prisma.types.BarberCountAggregateOutput
        results = Barber.prisma().count(
            select={
                '_all': True,
                'barberid': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = self._client._execute(
            operation='query',
            method='aggregate',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.BarberCountAggregateOutput, resp['data']['result']['_count'])

    def delete_many(
        self,
        where: Optional[types.BarberWhereInput] = None
    ) -> int:
        """Delete multiple Barber records.

        Parameters
        ----------
        where
            Optional Barber filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Barber records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Barber records
        total = Barber.prisma().delete_many()
        ```
        """
        resp = self._client._execute(
            operation='mutation',
            method='deleteMany',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    def group_by(
        self,
        by: List['types.BarberScalarFieldKeys'],
        *,
        where: Optional['types.BarberWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.BarberAvgAggregateInput'] = None,
        sum: Optional['types.BarberSumAggregateInput'] = None,
        min: Optional['types.BarberMinAggregateInput'] = None,
        max: Optional['types.BarberMaxAggregateInput'] = None,
        having: Optional['types.BarberScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.BarberCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.BarberScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.BarberScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.BarberGroupByOutput']:
        """Group Barber records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Barber fields to group records by
        where
            Barber filter to select records
        take
            Limit the maximum number of Barber records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.BarberGroupByOutput]
            A list of dictionaries representing the Barber record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Barber records by firstname values
        # and count how many records are in each group
        results = Barber.prisma().group_by(
            ['firstname'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = self._client._execute(
            operation='query',
            method='groupBy',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class CustomerActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Customer]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = Customer.prisma().query_raw(
            'SELECT * FROM Customer WHERE customerId = $1',
            1969681615,
        )
        ```
        """
        return self._client.query_raw(query, *args, model=self._model)

    def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Customer
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = Customer.prisma().query_first(
            'SELECT * FROM Customer WHERE firstname = $1',
            'bbbgbhfjge',
        )
        ```
        """
        return self._client.query_first(query, *args, model=self._model)

    def create(
        self,
        data: types.CustomerCreateInput,
        include: Optional[types.CustomerInclude] = None
    ) -> _PrismaModelT:
        """Create a new Customer record.

        Parameters
        ----------
        data
            Customer record data
        include
            Specifies which relations should be loaded on the returned Customer model

        Returns
        -------
        prisma.models.Customer
            The created Customer record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Customer record from just the required fields
        customer = Customer.prisma().create(
            data={
                # data to create a Customer record
                'firstname': 'igbehcbab',
                'lastname': 'bdadaadhag',
                'city': 'bgiggdidbf',
                'phonenumber': 'caaaedabfc',
                'email': 'bigibebcib',
                'password': 'bigaiehgcc',
                'is_authenticated': False,
                'is_active': True,
                'is_anonymous': False,
            },
        )
        ```
        """
        resp = self._client._execute(
            operation='mutation',
            method='createOne',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    def create_many(
        self,
        data: List[types.CustomerCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Customer records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Customer record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = Customer.prisma().create_many(
            data=[
                {
                    # data to create a Customer record
                    'firstname': 'idfjadbcc',
                    'lastname': 'hgdhbjhhj',
                    'city': 'ecjjjfbae',
                    'phonenumber': 'bhhfibbigf',
                    'email': 'ijdbeffgg',
                    'password': 'jjfeafhfj',
                    'is_authenticated': True,
                    'is_active': False,
                    'is_anonymous': True,
                },
                {
                    # data to create a Customer record
                    'firstname': 'caficfigfb',
                    'lastname': 'bfidgijfjc',
                    'city': 'ihieecagf',
                    'phonenumber': 'bghfciaafe',
                    'email': 'bgchfhgceh',
                    'password': 'cafeiaccbc',
                    'is_authenticated': False,
                    'is_active': True,
                    'is_anonymous': False,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = self._client._execute(
            operation='mutation',
            method='createMany',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    def delete(
        self,
        where: types.CustomerWhereUniqueInput,
        include: Optional[types.CustomerInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Customer record.

        Parameters
        ----------
        where
            Customer filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Customer model

        Returns
        -------
        prisma.models.Customer
            The deleted Customer record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        customer = Customer.prisma().delete(
            where={
                'customerId': 521827728,
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                operation='mutation',
                method='deleteOne',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    def find_unique(
        self,
        where: types.CustomerWhereUniqueInput,
        include: Optional[types.CustomerInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Customer record.

        Parameters
        ----------
        where
            Customer filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Customer model

        Returns
        -------
        prisma.models.Customer
            The found Customer record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        customer = Customer.prisma().find_unique(
            where={
                'customerId': 1266032265,
            },
        )
        ```
        """
        resp = self._client._execute(
            operation='query',
            method='findUnique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CustomerWhereInput] = None,
        cursor: Optional[types.CustomerWhereUniqueInput] = None,
        include: Optional[types.CustomerInclude] = None,
        order: Optional[Union[types.CustomerOrderByInput, List[types.CustomerOrderByInput]]] = None,
        distinct: Optional[List[types.CustomerScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Customer records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Customer records returned
        skip
            Ignore the first N results
        where
            Customer filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Customer model
        order
            Order the returned Customer records by any field
        distinct
            Filter Customer records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Customer]
            The list of all Customer records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Customer records
        customers = Customer.prisma().find_many(take=10)

        # find the first 5 Customer records ordered by the lastname field
        customers = Customer.prisma().find_many(
            take=5,
            order={
                'lastname': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            operation='query',
            method='findMany',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [self._model.parse_obj(r) for r in resp['data']['result']]

    def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CustomerWhereInput] = None,
        cursor: Optional[types.CustomerWhereUniqueInput] = None,
        include: Optional[types.CustomerInclude] = None,
        order: Optional[Union[types.CustomerOrderByInput, List[types.CustomerOrderByInput]]] = None,
        distinct: Optional[List[types.CustomerScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Customer record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Customer filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Customer model
        order
            Order the returned Customer records by any field
        distinct
            Filter Customer records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Customer
            The first Customer record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Customer record ordered by the city field
        customer = Customer.prisma().find_first(
            skip=1,
            order={
                'city': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            operation='query',
            method='findFirst',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    def update(
        self,
        data: types.CustomerUpdateInput,
        where: types.CustomerWhereUniqueInput,
        include: Optional[types.CustomerInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Customer record.

        Parameters
        ----------
        data
            Customer record data specifying what to update
        where
            Customer filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Customer model

        Returns
        -------
        prisma.models.Customer
            The updated Customer record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        customer = Customer.prisma().update(
            where={
                'customerId': 93253262,
            },
            data={
                # data to update the Customer record to
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                operation='mutation',
                method='updateOne',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    def upsert(
        self,
        where: types.CustomerWhereUniqueInput,
        data: types.CustomerUpsertInput,
        include: Optional[types.CustomerInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Customer filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Customer model

        Returns
        -------
        prisma.models.Customer
            The created or updated Customer record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        customer = Customer.prisma().upsert(
            where={
                'customerId': 2053047983,
            },
            data={
                'create': {
                    'customerId': 2053047983,
                    'firstname': 'caficfigfb',
                    'lastname': 'bfidgijfjc',
                    'city': 'ihieecagf',
                    'phonenumber': 'bghfciaafe',
                    'email': 'bgchfhgceh',
                    'password': 'cafeiaccbc',
                    'is_authenticated': False,
                    'is_active': True,
                    'is_anonymous': False,
                },
                'update': {
                    'firstname': 'caficfigfb',
                    'lastname': 'bfidgijfjc',
                    'city': 'ihieecagf',
                    'phonenumber': 'bghfciaafe',
                    'email': 'bgchfhgceh',
                    'password': 'cafeiaccbc',
                    'is_authenticated': False,
                    'is_active': True,
                    'is_anonymous': False,
                },
            },
        )
        ```
        """
        resp = self._client._execute(
            operation='mutation',
            method='upsertOne',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    def update_many(
        self,
        data: types.CustomerUpdateManyMutationInput,
        where: types.CustomerWhereInput,
    ) -> int:
        """Update multiple Customer records

        Parameters
        ----------
        data
            Customer data to update the selected Customer records to
        where
            Filter to select the Customer records to update

        Returns
        -------
        int
            The total number of Customer records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Customer records
        total = Customer.prisma().update_many(
            data={
                'phonenumber': 'gifdddbia'
            },
            where={}
        )
        ```
        """
        resp = self._client._execute(
            operation='mutation',
            method='updateMany',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CustomerWhereInput] = None,
        cursor: Optional[types.CustomerWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Customer records present in the database

        Parameters
        ----------
        select
            Select the Customer fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Customer filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CustomerCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = Customer.prisma().count()

        # results: prisma.types.CustomerCountAggregateOutput
        results = Customer.prisma().count(
            select={
                '_all': True,
                'ffavoriteBarber': True,
            },
        )
        ```
        """


    @overload
    def count(
        self,
        select: types.CustomerCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CustomerWhereInput] = None,
        cursor: Optional[types.CustomerWhereUniqueInput] = None,
    ) -> types.CustomerCountAggregateOutput:
        ...

    def count(
        self,
        select: Optional[types.CustomerCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CustomerWhereInput] = None,
        cursor: Optional[types.CustomerWhereUniqueInput] = None,
    ) -> Union[int, types.CustomerCountAggregateOutput]:
        """Count the number of Customer records present in the database

        Parameters
        ----------
        select
            Select the Customer fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Customer filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CustomerCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = Customer.prisma().count()

        # results: prisma.types.CustomerCountAggregateOutput
        results = Customer.prisma().count(
            select={
                '_all': True,
                'email': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = self._client._execute(
            operation='query',
            method='aggregate',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.CustomerCountAggregateOutput, resp['data']['result']['_count'])

    def delete_many(
        self,
        where: Optional[types.CustomerWhereInput] = None
    ) -> int:
        """Delete multiple Customer records.

        Parameters
        ----------
        where
            Optional Customer filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Customer records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Customer records
        total = Customer.prisma().delete_many()
        ```
        """
        resp = self._client._execute(
            operation='mutation',
            method='deleteMany',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    def group_by(
        self,
        by: List['types.CustomerScalarFieldKeys'],
        *,
        where: Optional['types.CustomerWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.CustomerAvgAggregateInput'] = None,
        sum: Optional['types.CustomerSumAggregateInput'] = None,
        min: Optional['types.CustomerMinAggregateInput'] = None,
        max: Optional['types.CustomerMaxAggregateInput'] = None,
        having: Optional['types.CustomerScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.CustomerCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.CustomerScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.CustomerScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.CustomerGroupByOutput']:
        """Group Customer records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Customer fields to group records by
        where
            Customer filter to select records
        take
            Limit the maximum number of Customer records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.CustomerGroupByOutput]
            A list of dictionaries representing the Customer record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Customer records by password values
        # and count how many records are in each group
        results = Customer.prisma().group_by(
            ['password'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = self._client._execute(
            operation='query',
            method='groupBy',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class TransactionActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Transaction]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = Transaction.prisma().query_raw(
            'SELECT * FROM Transaction WHERE transactionId = $1',
            127474245,
        )
        ```
        """
        return self._client.query_raw(query, *args, model=self._model)

    def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Transaction
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = Transaction.prisma().query_first(
            'SELECT * FROM Transaction WHERE fcustomerId = $1',
            948921754,
        )
        ```
        """
        return self._client.query_first(query, *args, model=self._model)

    def create(
        self,
        data: types.TransactionCreateInput,
        include: Optional[types.TransactionInclude] = None
    ) -> _PrismaModelT:
        """Create a new Transaction record.

        Parameters
        ----------
        data
            Transaction record data
        include
            Specifies which relations should be loaded on the returned Transaction model

        Returns
        -------
        prisma.models.Transaction
            The created Transaction record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Transaction record from just the required fields
        transaction = Transaction.prisma().create(
            data={
                # data to create a Transaction record
                'fcustomerId': 1964990155,
                'orderPrice': 1228891816,
                'fbarberId': 255202753,
            },
        )
        ```
        """
        resp = self._client._execute(
            operation='mutation',
            method='createOne',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    def create_many(
        self,
        data: List[types.TransactionCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Transaction records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Transaction record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = Transaction.prisma().create_many(
            data=[
                {
                    # data to create a Transaction record
                    'fcustomerId': 1223573862,
                    'orderPrice': 541269159,
                    'fbarberId': 1064846676,
                },
                {
                    # data to create a Transaction record
                    'fcustomerId': 508382461,
                    'orderPrice': 1024265714,
                    'fbarberId': 872078403,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = self._client._execute(
            operation='mutation',
            method='createMany',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    def delete(
        self,
        where: types.TransactionWhereUniqueInput,
        include: Optional[types.TransactionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Transaction record.

        Parameters
        ----------
        where
            Transaction filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Transaction model

        Returns
        -------
        prisma.models.Transaction
            The deleted Transaction record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        transaction = Transaction.prisma().delete(
            where={
                'transactionId': 1874748096,
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                operation='mutation',
                method='deleteOne',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    def find_unique(
        self,
        where: types.TransactionWhereUniqueInput,
        include: Optional[types.TransactionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Transaction record.

        Parameters
        ----------
        where
            Transaction filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Transaction model

        Returns
        -------
        prisma.models.Transaction
            The found Transaction record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        transaction = Transaction.prisma().find_unique(
            where={
                'transactionId': 916896761,
            },
        )
        ```
        """
        resp = self._client._execute(
            operation='query',
            method='findUnique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TransactionWhereInput] = None,
        cursor: Optional[types.TransactionWhereUniqueInput] = None,
        include: Optional[types.TransactionInclude] = None,
        order: Optional[Union[types.TransactionOrderByInput, List[types.TransactionOrderByInput]]] = None,
        distinct: Optional[List[types.TransactionScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Transaction records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Transaction records returned
        skip
            Ignore the first N results
        where
            Transaction filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Transaction model
        order
            Order the returned Transaction records by any field
        distinct
            Filter Transaction records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Transaction]
            The list of all Transaction records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Transaction records
        transactions = Transaction.prisma().find_many(take=10)

        # find the first 5 Transaction records ordered by the orderPrice field
        transactions = Transaction.prisma().find_many(
            take=5,
            order={
                'orderPrice': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            operation='query',
            method='findMany',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [self._model.parse_obj(r) for r in resp['data']['result']]

    def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TransactionWhereInput] = None,
        cursor: Optional[types.TransactionWhereUniqueInput] = None,
        include: Optional[types.TransactionInclude] = None,
        order: Optional[Union[types.TransactionOrderByInput, List[types.TransactionOrderByInput]]] = None,
        distinct: Optional[List[types.TransactionScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Transaction record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Transaction filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Transaction model
        order
            Order the returned Transaction records by any field
        distinct
            Filter Transaction records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Transaction
            The first Transaction record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Transaction record ordered by the fbarberId field
        transaction = Transaction.prisma().find_first(
            skip=1,
            order={
                'fbarberId': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            operation='query',
            method='findFirst',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    def update(
        self,
        data: types.TransactionUpdateInput,
        where: types.TransactionWhereUniqueInput,
        include: Optional[types.TransactionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Transaction record.

        Parameters
        ----------
        data
            Transaction record data specifying what to update
        where
            Transaction filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Transaction model

        Returns
        -------
        prisma.models.Transaction
            The updated Transaction record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        transaction = Transaction.prisma().update(
            where={
                'transactionId': 769267518,
            },
            data={
                # data to update the Transaction record to
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                operation='mutation',
                method='updateOne',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    def upsert(
        self,
        where: types.TransactionWhereUniqueInput,
        data: types.TransactionUpsertInput,
        include: Optional[types.TransactionInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Transaction filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Transaction model

        Returns
        -------
        prisma.models.Transaction
            The created or updated Transaction record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        transaction = Transaction.prisma().upsert(
            where={
                'transactionId': 820312479,
            },
            data={
                'create': {
                    'transactionId': 820312479,
                    'fcustomerId': 508382461,
                    'orderPrice': 1024265714,
                    'fbarberId': 872078403,
                },
                'update': {
                    'fcustomerId': 508382461,
                    'orderPrice': 1024265714,
                    'fbarberId': 872078403,
                },
            },
        )
        ```
        """
        resp = self._client._execute(
            operation='mutation',
            method='upsertOne',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    def update_many(
        self,
        data: types.TransactionUpdateManyMutationInput,
        where: types.TransactionWhereInput,
    ) -> int:
        """Update multiple Transaction records

        Parameters
        ----------
        data
            Transaction data to update the selected Transaction records to
        where
            Filter to select the Transaction records to update

        Returns
        -------
        int
            The total number of Transaction records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Transaction records
        total = Transaction.prisma().update_many(
            data={
                'Date': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = self._client._execute(
            operation='mutation',
            method='updateMany',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TransactionWhereInput] = None,
        cursor: Optional[types.TransactionWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Transaction records present in the database

        Parameters
        ----------
        select
            Select the Transaction fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Transaction filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TransactionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = Transaction.prisma().count()

        # results: prisma.types.TransactionCountAggregateOutput
        results = Transaction.prisma().count(
            select={
                '_all': True,
                'transactionId': True,
            },
        )
        ```
        """


    @overload
    def count(
        self,
        select: types.TransactionCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TransactionWhereInput] = None,
        cursor: Optional[types.TransactionWhereUniqueInput] = None,
    ) -> types.TransactionCountAggregateOutput:
        ...

    def count(
        self,
        select: Optional[types.TransactionCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TransactionWhereInput] = None,
        cursor: Optional[types.TransactionWhereUniqueInput] = None,
    ) -> Union[int, types.TransactionCountAggregateOutput]:
        """Count the number of Transaction records present in the database

        Parameters
        ----------
        select
            Select the Transaction fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Transaction filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TransactionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = Transaction.prisma().count()

        # results: prisma.types.TransactionCountAggregateOutput
        results = Transaction.prisma().count(
            select={
                '_all': True,
                'fcustomerId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = self._client._execute(
            operation='query',
            method='aggregate',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.TransactionCountAggregateOutput, resp['data']['result']['_count'])

    def delete_many(
        self,
        where: Optional[types.TransactionWhereInput] = None
    ) -> int:
        """Delete multiple Transaction records.

        Parameters
        ----------
        where
            Optional Transaction filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Transaction records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Transaction records
        total = Transaction.prisma().delete_many()
        ```
        """
        resp = self._client._execute(
            operation='mutation',
            method='deleteMany',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    def group_by(
        self,
        by: List['types.TransactionScalarFieldKeys'],
        *,
        where: Optional['types.TransactionWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.TransactionAvgAggregateInput'] = None,
        sum: Optional['types.TransactionSumAggregateInput'] = None,
        min: Optional['types.TransactionMinAggregateInput'] = None,
        max: Optional['types.TransactionMaxAggregateInput'] = None,
        having: Optional['types.TransactionScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.TransactionCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.TransactionScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.TransactionScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.TransactionGroupByOutput']:
        """Group Transaction records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Transaction fields to group records by
        where
            Transaction filter to select records
        take
            Limit the maximum number of Transaction records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.TransactionGroupByOutput]
            A list of dictionaries representing the Transaction record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Transaction records by orderPrice values
        # and count how many records are in each group
        results = Transaction.prisma().group_by(
            ['orderPrice'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = self._client._execute(
            operation='query',
            method='groupBy',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ContactActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Contact]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = Contact.prisma().query_raw(
            'SELECT * FROM Contact WHERE ContactId = $1',
            92728044,
        )
        ```
        """
        return self._client.query_raw(query, *args, model=self._model)

    def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Contact
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = Contact.prisma().query_first(
            'SELECT * FROM Contact WHERE Name = $1',
            'deeificjd',
        )
        ```
        """
        return self._client.query_first(query, *args, model=self._model)

    def create(
        self,
        data: types.ContactCreateInput,
        include: Optional[types.ContactInclude] = None
    ) -> _PrismaModelT:
        """Create a new Contact record.

        Parameters
        ----------
        data
            Contact record data
        include
            Specifies which relations should be loaded on the returned Contact model

        Returns
        -------
        prisma.models.Contact
            The created Contact record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Contact record from just the required fields
        contact = Contact.prisma().create(
            data={
                # data to create a Contact record
                'Name': 'bbcbhebbda',
                'Email': 'bejfijgcfb',
                'Message': 'caifcbgii',
            },
        )
        ```
        """
        resp = self._client._execute(
            operation='mutation',
            method='createOne',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    def create_many(
        self,
        data: List[types.ContactCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Contact records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Contact record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = Contact.prisma().create_many(
            data=[
                {
                    # data to create a Contact record
                    'Name': 'igaibbfgj',
                    'Email': 'bggajdcbbi',
                    'Message': 'fcfhgbjed',
                },
                {
                    # data to create a Contact record
                    'Name': 'hdgcajhjg',
                    'Email': 'ejdjahicb',
                    'Message': 'gdjgigfgc',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = self._client._execute(
            operation='mutation',
            method='createMany',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    def delete(
        self,
        where: types.ContactWhereUniqueInput,
        include: Optional[types.ContactInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Contact record.

        Parameters
        ----------
        where
            Contact filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Contact model

        Returns
        -------
        prisma.models.Contact
            The deleted Contact record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        contact = Contact.prisma().delete(
            where={
                'ContactId': 654007347,
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                operation='mutation',
                method='deleteOne',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    def find_unique(
        self,
        where: types.ContactWhereUniqueInput,
        include: Optional[types.ContactInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Contact record.

        Parameters
        ----------
        where
            Contact filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Contact model

        Returns
        -------
        prisma.models.Contact
            The found Contact record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        contact = Contact.prisma().find_unique(
            where={
                'ContactId': 1905261552,
            },
        )
        ```
        """
        resp = self._client._execute(
            operation='query',
            method='findUnique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ContactWhereInput] = None,
        cursor: Optional[types.ContactWhereUniqueInput] = None,
        include: Optional[types.ContactInclude] = None,
        order: Optional[Union[types.ContactOrderByInput, List[types.ContactOrderByInput]]] = None,
        distinct: Optional[List[types.ContactScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Contact records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Contact records returned
        skip
            Ignore the first N results
        where
            Contact filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Contact model
        order
            Order the returned Contact records by any field
        distinct
            Filter Contact records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Contact]
            The list of all Contact records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Contact records
        contacts = Contact.prisma().find_many(take=10)

        # find the first 5 Contact records ordered by the Email field
        contacts = Contact.prisma().find_many(
            take=5,
            order={
                'Email': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            operation='query',
            method='findMany',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [self._model.parse_obj(r) for r in resp['data']['result']]

    def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ContactWhereInput] = None,
        cursor: Optional[types.ContactWhereUniqueInput] = None,
        include: Optional[types.ContactInclude] = None,
        order: Optional[Union[types.ContactOrderByInput, List[types.ContactOrderByInput]]] = None,
        distinct: Optional[List[types.ContactScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Contact record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Contact filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Contact model
        order
            Order the returned Contact records by any field
        distinct
            Filter Contact records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Contact
            The first Contact record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Contact record ordered by the Message field
        contact = Contact.prisma().find_first(
            skip=1,
            order={
                'Message': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            operation='query',
            method='findFirst',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    def update(
        self,
        data: types.ContactUpdateInput,
        where: types.ContactWhereUniqueInput,
        include: Optional[types.ContactInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Contact record.

        Parameters
        ----------
        data
            Contact record data specifying what to update
        where
            Contact filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Contact model

        Returns
        -------
        prisma.models.Contact
            The updated Contact record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        contact = Contact.prisma().update(
            where={
                'ContactId': 78746985,
            },
            data={
                # data to update the Contact record to
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                operation='mutation',
                method='updateOne',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    def upsert(
        self,
        where: types.ContactWhereUniqueInput,
        data: types.ContactUpsertInput,
        include: Optional[types.ContactInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Contact filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Contact model

        Returns
        -------
        prisma.models.Contact
            The created or updated Contact record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        contact = Contact.prisma().upsert(
            where={
                'ContactId': 1398328302,
            },
            data={
                'create': {
                    'ContactId': 1398328302,
                    'Name': 'hdgcajhjg',
                    'Email': 'ejdjahicb',
                    'Message': 'gdjgigfgc',
                },
                'update': {
                    'Name': 'hdgcajhjg',
                    'Email': 'ejdjahicb',
                    'Message': 'gdjgigfgc',
                },
            },
        )
        ```
        """
        resp = self._client._execute(
            operation='mutation',
            method='upsertOne',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    def update_many(
        self,
        data: types.ContactUpdateManyMutationInput,
        where: types.ContactWhereInput,
    ) -> int:
        """Update multiple Contact records

        Parameters
        ----------
        data
            Contact data to update the selected Contact records to
        where
            Filter to select the Contact records to update

        Returns
        -------
        int
            The total number of Contact records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Contact records
        total = Contact.prisma().update_many(
            data={
                'ContactId': 856000655
            },
            where={}
        )
        ```
        """
        resp = self._client._execute(
            operation='mutation',
            method='updateMany',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ContactWhereInput] = None,
        cursor: Optional[types.ContactWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Contact records present in the database

        Parameters
        ----------
        select
            Select the Contact fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Contact filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ContactCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = Contact.prisma().count()

        # results: prisma.types.ContactCountAggregateOutput
        results = Contact.prisma().count(
            select={
                '_all': True,
                'Name': True,
            },
        )
        ```
        """


    @overload
    def count(
        self,
        select: types.ContactCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ContactWhereInput] = None,
        cursor: Optional[types.ContactWhereUniqueInput] = None,
    ) -> types.ContactCountAggregateOutput:
        ...

    def count(
        self,
        select: Optional[types.ContactCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ContactWhereInput] = None,
        cursor: Optional[types.ContactWhereUniqueInput] = None,
    ) -> Union[int, types.ContactCountAggregateOutput]:
        """Count the number of Contact records present in the database

        Parameters
        ----------
        select
            Select the Contact fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Contact filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ContactCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = Contact.prisma().count()

        # results: prisma.types.ContactCountAggregateOutput
        results = Contact.prisma().count(
            select={
                '_all': True,
                'Email': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = self._client._execute(
            operation='query',
            method='aggregate',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ContactCountAggregateOutput, resp['data']['result']['_count'])

    def delete_many(
        self,
        where: Optional[types.ContactWhereInput] = None
    ) -> int:
        """Delete multiple Contact records.

        Parameters
        ----------
        where
            Optional Contact filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Contact records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Contact records
        total = Contact.prisma().delete_many()
        ```
        """
        resp = self._client._execute(
            operation='mutation',
            method='deleteMany',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    def group_by(
        self,
        by: List['types.ContactScalarFieldKeys'],
        *,
        where: Optional['types.ContactWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ContactAvgAggregateInput'] = None,
        sum: Optional['types.ContactSumAggregateInput'] = None,
        min: Optional['types.ContactMinAggregateInput'] = None,
        max: Optional['types.ContactMaxAggregateInput'] = None,
        having: Optional['types.ContactScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ContactCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ContactScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ContactScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ContactGroupByOutput']:
        """Group Contact records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Contact fields to group records by
        where
            Contact filter to select records
        take
            Limit the maximum number of Contact records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ContactGroupByOutput]
            A list of dictionaries representing the Contact record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Contact records by Message values
        # and count how many records are in each group
        results = Contact.prisma().group_by(
            ['Message'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = self._client._execute(
            operation='query',
            method='groupBy',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]



def _select_fields(root: str, select: Mapping[str, Any]) -> str:
    """Helper to build a GraphQL selection string

    This is a work around until field selection is added to the query builder.
    """

    return root + ' {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))


from . import models
